/*-----------------------------------------------------------------------------

 Copyright 2017 Hopsan Group

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.


 The full license is available in the file LICENSE.
 For details about the 'Hopsan Group' or information about Authors and
 Contributors see the HOPSANGROUP and AUTHORS files that are located in
 the Hopsan source code root directory.

-----------------------------------------------------------------------------*/

#ifndef PNEUMATICTURBOMACHINEJ_HPP_INCLUDED
#define PNEUMATICTURBOMACHINEJ_HPP_INCLUDED

#include <iostream>
#include "ComponentEssentials.h"
#include "ComponentUtilities.h"
#include "math.h"

//!
//! @file PneumaticTurboMachineJ.hpp
//! @author Petter Krus <petter.krus@liu.se>
//! @date Sat 3 Jan 2015 19:10:14
//! @brief Turbo compressor
//! @ingroup PneumaticComponents
//!
//==This code has been autogenerated using Compgen==
//from 
/*{, C:, HopsanTrunk, componentLibraries, defaultLibrary, Special, \
AeroComponents}/PneumaticTurboMachine.nb*/

using namespace hopsan;

class PneumaticTurboMachineJ : public ComponentQ
{
private:
     double kl;
     double b;
     double d;
     double beta2;
     double A1;
     double A2;
     double rho;
     double Kcp;
     double Bm;
     double Jm;
     double R;
     double cv;
     Port *mpPp1;
     Port *mpPp2;
     Port *mpPmr1;
     double delayParts1[9];
     double delayParts2[9];
     double delayParts3[9];
     double delayParts4[9];
     double delayParts5[9];
     double delayParts6[9];
     double delayParts7[9];
     Matrix jacobianMatrix;
     Vec systemEquations;
     Matrix delayedPart;
     int i;
     int iter;
     int mNoiter;
     double jsyseqnweight[4];
     int order[7];
     int mNstep;
     //Port Pp1 variable
     double pp1;
     double qmp1;
     double Tp1;
     double dEp1;
     double cp1;
     double Zcp1;
     //Port Pp2 variable
     double pp2;
     double qmp2;
     double Tp2;
     double dEp2;
     double cp2;
     double Zcp2;
     //Port Pmr1 variable
     double tormr1;
     double thetamr1;
     double wmr1;
     double cmr1;
     double Zcmr1;
     double eqInertiamr1;
//==This code has been autogenerated using Compgen==
     //inputVariables
     //outputVariables
     double q2;
     //Expressions variables
     //Port Pp1 pointer
     double *mpND_pp1;
     double *mpND_qmp1;
     double *mpND_Tp1;
     double *mpND_dEp1;
     double *mpND_cp1;
     double *mpND_Zcp1;
     //Port Pp2 pointer
     double *mpND_pp2;
     double *mpND_qmp2;
     double *mpND_Tp2;
     double *mpND_dEp2;
     double *mpND_cp2;
     double *mpND_Zcp2;
     //Port Pmr1 pointer
     double *mpND_tormr1;
     double *mpND_thetamr1;
     double *mpND_wmr1;
     double *mpND_cmr1;
     double *mpND_Zcmr1;
     double *mpND_eqInertiamr1;
     //Delay declarations
//==This code has been autogenerated using Compgen==
     //inputVariables pointers
     //inputParameters pointers
     double *mpkl;
     double *mpb;
     double *mpd;
     double *mpbeta2;
     double *mpA1;
     double *mpA2;
     double *mprho;
     double *mpKcp;
     double *mpBm;
     double *mpJm;
     double *mpR;
     double *mpcv;
     //outputVariables pointers
     double *mpq2;
     Delay mDelayedPart10;
     Delay mDelayedPart20;
     Delay mDelayedPart21;
     Delay mDelayedPart30;
     Delay mDelayedPart40;
     EquationSystemSolver *mpSolver = nullptr;

public:
     static Component *Creator()
     {
        return new PneumaticTurboMachineJ();
     }

     void configure()
     {
//==This code has been autogenerated using Compgen==

        mNstep=9;
        jacobianMatrix.create(7,7);
        systemEquations.create(7);
        delayedPart.create(8,6);
        mNoiter=2;
        jsyseqnweight[0]=1;
        jsyseqnweight[1]=0.67;
        jsyseqnweight[2]=0.5;
        jsyseqnweight[3]=0.5;


        //Add ports to the component
        mpPp1=addPowerPort("Pp1","NodePneumatic");
        mpPp2=addPowerPort("Pp2","NodePneumatic");
        mpPmr1=addPowerPort("Pmr1","NodeMechanicRotational");
        //Add inputVariables to the component

        //Add inputParammeters to the component
            addInputVariable("kl", "Flow loss koeff.", "", 1.,&mpkl);
            addInputVariable("b", "outlet axial width", "m", 0.02,&mpb);
            addInputVariable("d", "Diameter", "m", 0.26,&mpd);
            addInputVariable("beta2", "Outlet flow angle", "rad", \
1.59,&mpbeta2);
            addInputVariable("A1", "inlet flow area", "m2", 0.0004,&mpA1);
            addInputVariable("A2", "outlet flow area", "m2", 0.0004,&mpA2);
            addInputVariable("rho", "Fluid density", "kg/m2", 870, &mprho);
            addInputVariable("Kcp", "Leakage coeff", "m3/s/Pa", \
1.e-9,&mpKcp);
            addInputVariable("Bm", "Visc friction coeff", "N/m/s", 1.,&mpBm);
            addInputVariable("Jm", "Moment of inertia", "kg/m2", 0.1,&mpJm);
            addInputVariable("R", "Gas constant", "J/Kg K", 287.,&mpR);
            addInputVariable("cv", "heatcoeff", "J/Kg K", 718,&mpcv);
        //Add outputVariables to the component
            addOutputVariable("q2","uncorrected flow","m3/s",0.,&mpq2);

//==This code has been autogenerated using Compgen==
        //Add constantParameters
        mpSolver = new EquationSystemSolver(this,7);
     }

    void initialize()
     {
        //Read port variable pointers from nodes
        //Port Pp1
        mpND_pp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::Pressure);
        mpND_qmp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::MassFlow);
        mpND_Tp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::Temperature);
        mpND_dEp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::EnergyFlow);
        mpND_cp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::WaveVariable);
        mpND_Zcp1=getSafeNodeDataPtr(mpPp1, NodePneumatic::CharImpedance);
        //Port Pp2
        mpND_pp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::Pressure);
        mpND_qmp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::MassFlow);
        mpND_Tp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::Temperature);
        mpND_dEp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::EnergyFlow);
        mpND_cp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::WaveVariable);
        mpND_Zcp2=getSafeNodeDataPtr(mpPp2, NodePneumatic::CharImpedance);
        //Port Pmr1
        mpND_tormr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::Torque);
        mpND_thetamr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::Angle);
        mpND_wmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::AngularVelocity);
        mpND_cmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::WaveVariable);
        mpND_Zcmr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::CharImpedance);
        mpND_eqInertiamr1=getSafeNodeDataPtr(mpPmr1, \
NodeMechanicRotational::EquivalentInertia);

        //Read variables from nodes
        //Port Pp1
        pp1 = (*mpND_pp1);
        qmp1 = (*mpND_qmp1);
        Tp1 = (*mpND_Tp1);
        dEp1 = (*mpND_dEp1);
        cp1 = (*mpND_cp1);
        Zcp1 = (*mpND_Zcp1);
        //Port Pp2
        pp2 = (*mpND_pp2);
        qmp2 = (*mpND_qmp2);
        Tp2 = (*mpND_Tp2);
        dEp2 = (*mpND_dEp2);
        cp2 = (*mpND_cp2);
        Zcp2 = (*mpND_Zcp2);
        //Port Pmr1
        tormr1 = (*mpND_tormr1);
        thetamr1 = (*mpND_thetamr1);
        wmr1 = (*mpND_wmr1);
        cmr1 = (*mpND_cmr1);
        Zcmr1 = (*mpND_Zcmr1);
        eqInertiamr1 = (*mpND_eqInertiamr1);

        //Read inputVariables from nodes

        //Read inputParameters from nodes
        kl = (*mpkl);
        b = (*mpb);
        d = (*mpd);
        beta2 = (*mpbeta2);
        A1 = (*mpA1);
        A2 = (*mpA2);
        rho = (*mprho);
        Kcp = (*mpKcp);
        Bm = (*mpBm);
        Jm = (*mpJm);
        R = (*mpR);
        cv = (*mpcv);

        //Read outputVariables from nodes
        q2 = (*mpq2);

//==This code has been autogenerated using Compgen==


        //Initialize delays
        delayParts2[1] = (-1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1 - \
2.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp1 + \
2.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp1 + \
0.002*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1 - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Power(Tp1,2) + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2) - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp2 + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp2 + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp2 - \
2.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
2.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp1*Tp2 + \
0.002*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Tp2 - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*wmr1 - \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*wmr1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*wmr1 - \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*wmr1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1 + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Abs(wmr1) + \
2.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*wmr1*Abs(wmr1) - \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*wmr1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*wmr1*Abs(wmr1) - \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*wmr1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*onNegative(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*onNegative(qmp2) + \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*onNegative(qmp2) - \
4.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*onNegative(qmp2) + \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*Tp1*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Power(Tp1,2)*onNegativ\
e(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Power(Tp1,2)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*Power(Tp1,2)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp\
2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*Tp2*onPositive(qmp\
2) + 1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*onNegative(qmp2)*sign(q\
mp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*onNegative(qmp2)*sign(q\
mp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*onNegative(qmp2)*si\
gn(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*onNegative(qmp2)*si\
gn(qmp2) - \
1.*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onNegative(qmp2)*sig\
n(qmp2) + \
1.*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp2*onNegative(qmp2)*sig\
n(qmp2) - \
1.*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*Tp2*onNegative(qmp2)\
*sign(qmp2) + \
1.*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*Tp2*onNegative(qmp2)\
*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onNegative\
(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Power(Tp2,2)*onNegative\
(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*Power(Tp2,2)*onNega\
tive(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*Power(Tp2,2)*onNega\
tive(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) \
+ \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(q\
mp2) - \
1.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(q\
mp2) + \
1.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*si\
gn(qmp2) - \
1.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp\
2)*sign(qmp2) + \
1.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive\
(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp\
2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive\
(qmp2)*sign(qmp2))/(0.002*Power(A2,2)*Jm*Power(pp2,2)*R + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R + \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1 + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2) + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2 + \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Abs(wmr1) + \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*Abs(wmr1) + \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*Abs(wmr1));
        mDelayedPart21.initialize(mNstep,delayParts2[1]);

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];
     }
    void simulateOneTimestep()
     {
        Vec stateVar(7);
        Vec stateVark(7);
        Vec deltaStateVar(7);

        //Read variables from nodes
        //Port Pp1
        Tp1 = (*mpND_Tp1);
        cp1 = (*mpND_cp1);
        Zcp1 = (*mpND_Zcp1);
        //Port Pp2
        Tp2 = (*mpND_Tp2);
        cp2 = (*mpND_cp2);
        Zcp2 = (*mpND_Zcp2);
        //Port Pmr1
        cmr1 = (*mpND_cmr1);
        Zcmr1 = (*mpND_Zcmr1);

        //Read inputVariables from nodes

        //LocalExpressions

        //Initializing variable vector for Newton-Raphson
        stateVark[0] = qmp2;
        stateVark[1] = wmr1;
        stateVark[2] = dEp1;
        stateVark[3] = dEp2;
        stateVark[4] = pp1;
        stateVark[5] = pp2;
        stateVark[6] = tormr1;

        //Iterative solution using Newton-Rapshson
        for(iter=1;iter<=mNoiter;iter++)
        {
         //TurboMachineJ
         //Differential-algebraic system of equation parts

          //Assemble differential-algebraic equations
          systemEquations[0] =qmp2 + (A2*(pp2*(-1. - 1.*Tp1)*onNegative(qmp2) \
+ pp1*(-1. - 1.*Tp2)*onPositive(qmp2))*signedSquareL((2*R*(1. + Tp2)*(pp1 - \
pp2 + (Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.))/(R*(1. + 1.*Tp2 + Tp1*(1. + Tp2)));
          systemEquations[1] =wmr1 + delayedPart[2][1] + \
(mTimestep*(-1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R + 0.001*Power(A2,2)*Power(pp2,2)*R*tormr1 \
- 2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2) - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp2 - \
2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1*Tp2 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2 + \
Power(A2,2)*Power(pp2,2)*R*tormr1*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2))*Abs(wmr1) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qm\
p2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sig\
n(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qm\
p2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sig\
n(qmp2) + \
Kcp*pp2*onNegative(qmp2)*(Power(A2,2)*Power(pp2,2)*(Power(pp1,2)*Power(1. + \
1.*Tp1,2) + Power(pp2,2)*Power(1. + 1.*Tp1,2) - \
1.*pp1*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(-1.*pp1 + pp2 - 1.*pp1*Tp1 + \
pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTime\
step*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + \
0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1)));
          systemEquations[2] =dEp1 + qmp2*((cv + R)*Tp1*onNegative(-qmp2) + \
(pp1 - pp2 + (cv + R)*Tp2)*onPositive(-qmp2));
          systemEquations[3] =dEp2 - qmp2*((cv + R)*Tp2*onNegative(qmp2) + \
(-pp1 + pp2 + (cv + R)*Tp1)*onPositive(qmp2));
          systemEquations[4] =pp1 - lowLimit(cp1 + dEp1*Zcp1,0.);
          systemEquations[5] =pp2 - lowLimit(cp2 + dEp2*Zcp2,0.);
          systemEquations[6] =-cmr1 + tormr1 - wmr1*Zcmr1;

          //Jacobian matrix
          jacobianMatrix[0][0] = 1. + \
(2*A2*Abs(wmr1)*dxSignedSquareL((2*R*(1. + Tp2)*(pp1 - pp2 + \
(Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.)*(pp2*(-1. - 1.*Tp1)*onNegative(qmp2) + pp1*(-1. - \
1.*Tp2)*onPositive(qmp2))*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(0. + pp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2)))/(b*kl*Power(pp2,2)*R*P\
ower(1. + Tp1,2)*(1. + 1.*Tp2 + Tp1*(1. + Tp2)));
          jacobianMatrix[0][1] = 0. + (2*A2*(1. + \
Tp2)*dxSignedSquareL((2*R*(1. + Tp2)*(pp1 - pp2 + (Abs(wmr1)*(pp2*(1. + \
Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.)*(pp2*(-1. - 1.*Tp1)*onNegative(qmp2) + pp1*(-1. - \
1.*Tp2)*onPositive(qmp2))*((dxAbs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + \
pp1*(1. + Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + Tp2)) + \
(Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(0. + b*Power(d,2)*pp2*(0.25 + \
0.25*Tp1)*dxAbs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2*(1. + 1.*Tp2 + Tp1*(1. + Tp2)));
          jacobianMatrix[0][2] = 0;
          jacobianMatrix[0][3] = 0;
          jacobianMatrix[0][4] = 0. + (2*A2*(1. + \
Tp2)*dxSignedSquareL((2*R*(1. + Tp2)*(pp1 - pp2 + (Abs(wmr1)*(pp2*(1. + \
Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.)*(pp2*(-1. - 1.*Tp1)*onNegative(qmp2) + pp1*(-1. - \
1.*Tp2)*onPositive(qmp2))*(1 + (Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + \
pp1*(1. + Tp2)*onPositive(qmp2))*(0. + qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2)))/(b*pp2*R*Power(1. + \
Tp1,2)*(1. + Tp2)) + \
(Abs(wmr1)*onPositive(qmp2)*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2))))/(kl*pp2*(1. \
+ 1.*Tp2 + Tp1*(1. + Tp2))) + (A2*(0. + (-1. - \
1.*Tp2)*onPositive(qmp2))*signedSquareL((2*R*(1. + Tp2)*(pp1 - pp2 + \
(Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.))/(R*(1. + 1.*Tp2 + Tp1*(1. + Tp2)));
          jacobianMatrix[0][5] = 0. + (A2*dxSignedSquareL((2*R*(1. + \
Tp2)*(pp1 - pp2 + (Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.)*(pp2*(-1. - 1.*Tp1)*onNegative(qmp2) + pp1*(-1. - \
1.*Tp2)*onPositive(qmp2))*((2*R*(1. + Tp2)*(-1 + (Abs(wmr1)*(pp2*(1. + \
Tp1)*onNegative(qmp2) + pp1*(1. + Tp2)*onPositive(qmp2))*(0. + \
qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + b*Power(d,2)*(0.25 + \
0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + Tp2)) + \
(Abs(wmr1)*onNegative(qmp2)*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*(1. + Tp1)*(1. + Tp2)) - \
(Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*Power(pp2,2)*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2) - (2*R*(1. + Tp2)*(pp1 - pp2 + (Abs(wmr1)*(pp2*(1. + \
Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*Power(pp2,2))))/(R*(1. + 1.*Tp2 + Tp1*(1. + Tp2))) + (A2*(0. + \
(-1. - 1.*Tp1)*onNegative(qmp2))*signedSquareL((2*R*(1. + Tp2)*(pp1 - pp2 + \
(Abs(wmr1)*(pp2*(1. + Tp1)*onNegative(qmp2) + pp1*(1. + \
Tp2)*onPositive(qmp2))*(pp2*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp1)*Cot(beta2)*onNegative(qmp2) + \
pp1*qmp2*(-0.15915494309189535 - \
0.15915494309189535*Tp2)*Cot(beta2)*onPositive(qmp2) + b*Power(d,2)*pp2*(0.25 \
+ 0.25*Tp1)*Abs(wmr1)*sign(-wmr1)))/(b*pp2*R*Power(1. + Tp1,2)*(1. + \
Tp2))))/(kl*pp2),1000.))/(R*(1. + 1.*Tp2 + Tp1*(1. + Tp2)));
          jacobianMatrix[0][6] = 0.;
          jacobianMatrix[1][0] = 0. + (mTimestep*(0. - \
1.*Power(A2,2)*pp1*Power(pp2,2)*R + 1.*Power(A2,2)*Power(pp2,3)*R - \
2.*Power(A2,2)*pp1*Power(pp2,2)*R*Tp1 + 2.*Power(A2,2)*Power(pp2,3)*R*Tp1 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*R*Power(Tp1,2) + \
1.*Power(A2,2)*Power(pp2,3)*R*Power(Tp1,2) - \
1.*Power(A2,2)*pp1*Power(pp2,2)*R*Tp2 + 1.*Power(A2,2)*Power(pp2,3)*R*Tp2 - \
2.*Power(A2,2)*pp1*Power(pp2,2)*R*Tp1*Tp2 + \
2.*Power(A2,2)*Power(pp2,3)*R*Tp1*Tp2 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*R*Power(Tp1,2)*Tp2 + \
1.5*kl*pp1*Power(qmp2,2)*Power(R,2)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Tp1*sign(qmp2) + \
4.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Tp2*sign(qmp2) + \
4.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
4.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
4.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,2)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
1.*Kcp*kl*Power(pp1,3)*qmp2*R*onPositive(qmp2)*sign(qmp2) + \
1.*Kcp*kl*Power(pp1,2)*pp2*qmp2*R*onPositive(qmp2)*sign(qmp2) - \
3.*Kcp*kl*Power(pp1,3)*qmp2*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
3.*Kcp*kl*Power(pp1,2)*pp2*qmp2*R*Tp2*onPositive(qmp2)*sign(qmp2) - \
3.*Kcp*kl*Power(pp1,3)*qmp2*R*Power(Tp2,2)*onPositive(qmp2)*sign(qmp2) + \
3.*Kcp*kl*Power(pp1,2)*pp2*qmp2*R*Power(Tp2,2)*onPositive(qmp2)*sign(qmp2) - \
1.*Kcp*kl*Power(pp1,3)*qmp2*R*Power(Tp2,3)*onPositive(qmp2)*sign(qmp2) + \
1.*Kcp*kl*Power(pp1,2)*pp2*qmp2*R*Power(Tp2,3)*onPositive(qmp2)*sign(qmp2) + \
Kcp*pp2*onNegative(qmp2)*(0. + 2*kl*pp1*qmp2*R*(-1.*pp1 + pp2 - 1.*pp1*Tp1 + \
pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTime\
step*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + \
0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1)));
          jacobianMatrix[1][1] = 1 + (mTimestep*(0. + \
Power(A2,2)*Power(pp2,2)*R*tormr1*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + \
2.*Tp2))*dxAbs(wmr1)))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTimestep*(0.001 + \
Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + 0.001*Tp2) + \
Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + 0.004*Tp2) + \
0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + Tp1*(4. + \
4.*Tp2)))*Abs(wmr1))) - (mTimestep*(0. + (Bm*mTimestep*(1. + 1.*Tp2 + \
Power(Tp1,2)*(1. + 1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + \
Power(Tp1,2)*(2. + 2.*Tp2) + Tp1*(4. + \
4.*Tp2)))*dxAbs(wmr1))*(-1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R + 0.001*Power(A2,2)*Power(pp2,2)*R*tormr1 \
- 2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2) - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp2 - \
2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1*Tp2 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2 + \
Power(A2,2)*Power(pp2,2)*R*tormr1*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2))*Abs(wmr1) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qm\
p2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sig\
n(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qm\
p2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sig\
n(qmp2) + \
Kcp*pp2*onNegative(qmp2)*(Power(A2,2)*Power(pp2,2)*(Power(pp1,2)*Power(1. + \
1.*Tp1,2) + Power(pp2,2)*Power(1. + 1.*Tp1,2) - \
1.*pp1*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(-1.*pp1 + pp2 - 1.*pp1*Tp1 + \
pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,2)*R*Power(Bm*\
mTimestep*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) \
+ 0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1),2));
          jacobianMatrix[1][2] = 0;
          jacobianMatrix[1][3] = 0;
          jacobianMatrix[1][4] = 0. + (mTimestep*(0. - \
1.*Power(A2,2)*Power(pp2,2)*qmp2*R - 2.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp1 - \
1.*Power(A2,2)*Power(pp2,2)*qmp2*R*Power(Tp1,2) - \
1.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp2 - \
2.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp1*Tp2 - \
1.*Power(A2,2)*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
3.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*onPositive(qmp2) - \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp2,4)*onPositive(qmp2) + \
3.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp2,4)*Tp1*onPositive(qmp2) + \
3.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp2,4)*Tp2*onPositive(qmp2) + \
3.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp2) - \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp1*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) + \
1.*Kcp*kl*pp1*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) - \
4.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
3.*Kcp*kl*pp1*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) - \
4.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qm\
p2) + \
3.*Kcp*kl*pp1*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qm\
p2) + \
1.*Kcp*kl*pp1*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qmp2) + \
Kcp*pp2*onNegative(qmp2)*(0. + Power(A2,2)*Power(pp2,2)*(0. + 2*pp1*Power(1. \
+ 1.*Tp1,2) - 1.*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(-1. - 1.*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2) + kl*Power(qmp2,2)*R*(-1.*pp1 + pp2 - \
1.*pp1*Tp1 + pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTime\
step*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + \
0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1)));
          jacobianMatrix[1][5] = (mTimestep*(0. - \
2.*Power(A2,2)*pp1*pp2*qmp2*R + 3.*Power(A2,2)*Power(pp2,2)*qmp2*R + \
0.002*Power(A2,2)*pp2*R*tormr1 - 4.*Power(A2,2)*pp1*pp2*qmp2*R*Tp1 + \
6.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp1 + 0.004*Power(A2,2)*pp2*R*tormr1*Tp1 - \
2.*Power(A2,2)*pp1*pp2*qmp2*R*Power(Tp1,2) + \
3.*Power(A2,2)*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
0.002*Power(A2,2)*pp2*R*tormr1*Power(Tp1,2) - \
2.*Power(A2,2)*pp1*pp2*qmp2*R*Tp2 + 3.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp2 + \
0.002*Power(A2,2)*pp2*R*tormr1*Tp2 - 4.*Power(A2,2)*pp1*pp2*qmp2*R*Tp1*Tp2 + \
6.*Power(A2,2)*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
0.004*Power(A2,2)*pp2*R*tormr1*Tp1*Tp2 - \
2.*Power(A2,2)*pp1*pp2*qmp2*R*Power(Tp1,2)*Tp2 + \
3.*Power(A2,2)*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.002*Power(A2,2)*pp2*R*tormr1*Power(Tp1,2)*Tp2 + \
2*Power(A2,2)*pp2*R*tormr1*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2))*Abs(wmr1) + \
2.*Power(A2,2)*Kcp*Power(pp1,3)*pp2*onPositive(qmp2) - \
6.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*onPositive(qmp2) + \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*onPositive(qmp2) + \
2.*Power(A2,2)*Kcp*Power(pp1,3)*pp2*Tp1*onPositive(qmp2) - \
6.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp1*onPositive(qmp2) + \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp1*onPositive(qmp2) + \
2.*Power(A2,2)*Kcp*Power(pp1,3)*pp2*Tp2*onPositive(qmp2) - \
6.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp2*onPositive(qmp2) + \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp2*onPositive(qmp2) + \
2.*Power(A2,2)*Kcp*Power(pp1,3)*pp2*Tp1*Tp2*onPositive(qmp2) - \
6.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp2) + \
4.*Power(A2,2)*Kcp*pp1*Power(pp2,3)*Tp1*Tp2*onPositive(qmp2) + \
0.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) + \
1.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
1.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qm\
p2) + \
0.5*Kcp*kl*Power(pp1,2)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qm\
p2) + Kcp*pp2*onNegative(qmp2)*(0. + Power(A2,2)*Power(pp2,2)*(0. + \
2*pp2*Power(1. + 1.*Tp1,2) - 1.*pp1*Power(1.4142135623730951 + \
1.4142135623730951*Tp1,2)) + 2*Power(A2,2)*pp2*(Power(pp1,2)*Power(1. + \
1.*Tp1,2) + Power(pp2,2)*Power(1. + 1.*Tp1,2) - \
1.*pp1*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(1. + Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2)) + \
Kcp*onNegative(qmp2)*(Power(A2,2)*Power(pp2,2)*(Power(pp1,2)*Power(1. + \
1.*Tp1,2) + Power(pp2,2)*Power(1. + 1.*Tp1,2) - \
1.*pp1*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(-1.*pp1 + pp2 - 1.*pp1*Tp1 + \
pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTime\
step*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + \
0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1))) - \
(2*mTimestep*(-1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R + 0.001*Power(A2,2)*Power(pp2,2)*R*tormr1 \
- 2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2) - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp2 - \
2.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
2.*Power(A2,2)*Power(pp2,3)*qmp2*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Power(pp2,2)*R*tormr1*Tp1*Tp2 - \
1.*Power(A2,2)*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*Power(pp2,3)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2 + \
Power(A2,2)*Power(pp2,2)*R*tormr1*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2))*Abs(wmr1) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*Power(pp1,3)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*Power(pp1,2)*Power(pp2,3)*Tp1*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*pp1*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(qmp2) - \
1.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sign(qm\
p2) + \
1.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp2)*sig\
n(qmp2) - \
0.5*Kcp*kl*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sign(qm\
p2) + \
0.5*Kcp*kl*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp2)*sig\
n(qmp2) + \
Kcp*pp2*onNegative(qmp2)*(Power(A2,2)*Power(pp2,2)*(Power(pp1,2)*Power(1. + \
1.*Tp1,2) + Power(pp2,2)*Power(1. + 1.*Tp1,2) - \
1.*pp1*pp2*Power(1.4142135623730951 + 1.4142135623730951*Tp1,2)) + \
kl*pp1*Power(qmp2,2)*R*(-1.*pp1 + pp2 - 1.*pp1*Tp1 + \
pp2*Tp1)*Power(0.7071067811865476 + \
0.7071067811865476*Tp2,2)*sign(qmp2))))/(Power(A2,2)*Power(pp2,3)*R*(Bm*mTime\
step*(0.001 + Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + \
0.001*Tp2) + Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + \
0.004*Tp2) + 0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + \
1.*Tp2) + Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + \
Tp1*(4. + 4.*Tp2)))*Abs(wmr1)));
          jacobianMatrix[1][6] = 0. + (mTimestep*(0. + \
0.001*Power(A2,2)*Power(pp2,2)*R + 0.002*Power(A2,2)*Power(pp2,2)*R*Tp1 + \
0.001*Power(A2,2)*Power(pp2,2)*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Power(pp2,2)*R*Tp2 + \
0.002*Power(A2,2)*Power(pp2,2)*R*Tp1*Tp2 + \
0.001*Power(A2,2)*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
Power(A2,2)*Power(pp2,2)*R*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + \
2.*Tp2))*Abs(wmr1)))/(Power(A2,2)*Power(pp2,2)*R*(Bm*mTimestep*(0.001 + \
Power(Tp1,2)*(0.001 + 0.001*Tp2) + Tp1*(0.002 + 0.002*Tp2) + 0.001*Tp2) + \
Jm*(0.002 + Power(Tp1,2)*(0.002 + 0.002*Tp2) + Tp1*(0.004 + 0.004*Tp2) + \
0.002*Tp2) + (Bm*mTimestep*(1. + 1.*Tp2 + Power(Tp1,2)*(1. + 1.*Tp2) + \
Tp1*(2. + 2.*Tp2)) + Jm*(2. + 2.*Tp2 + Power(Tp1,2)*(2. + 2.*Tp2) + Tp1*(4. + \
4.*Tp2)))*Abs(wmr1)));
          jacobianMatrix[2][0] = (cv + R)*Tp1*onNegative(-qmp2) + (pp1 - pp2 \
+ (cv + R)*Tp2)*onPositive(-qmp2);
          jacobianMatrix[2][1] = 0;
          jacobianMatrix[2][2] = 1;
          jacobianMatrix[2][3] = 0;
          jacobianMatrix[2][4] = qmp2*onPositive(-qmp2);
          jacobianMatrix[2][5] = -(qmp2*onPositive(-qmp2));
          jacobianMatrix[2][6] = 0;
          jacobianMatrix[3][0] = -((cv + R)*Tp2*onNegative(qmp2)) - (-pp1 + \
pp2 + (cv + R)*Tp1)*onPositive(qmp2);
          jacobianMatrix[3][1] = 0;
          jacobianMatrix[3][2] = 0;
          jacobianMatrix[3][3] = 1;
          jacobianMatrix[3][4] = qmp2*onPositive(qmp2);
          jacobianMatrix[3][5] = -(qmp2*onPositive(qmp2));
          jacobianMatrix[3][6] = 0;
          jacobianMatrix[4][0] = 0;
          jacobianMatrix[4][1] = 0;
          jacobianMatrix[4][2] = -(Zcp1*dxLowLimit(cp1 + dEp1*Zcp1,0.));
          jacobianMatrix[4][3] = 0;
          jacobianMatrix[4][4] = 1;
          jacobianMatrix[4][5] = 0;
          jacobianMatrix[4][6] = 0;
          jacobianMatrix[5][0] = 0;
          jacobianMatrix[5][1] = 0;
          jacobianMatrix[5][2] = 0;
          jacobianMatrix[5][3] = -(Zcp2*dxLowLimit(cp2 + dEp2*Zcp2,0.));
          jacobianMatrix[5][4] = 0;
          jacobianMatrix[5][5] = 1;
          jacobianMatrix[5][6] = 0;
          jacobianMatrix[6][0] = 0;
          jacobianMatrix[6][1] = -Zcmr1;
          jacobianMatrix[6][2] = 0;
          jacobianMatrix[6][3] = 0;
          jacobianMatrix[6][4] = 0;
          jacobianMatrix[6][5] = 0;
          jacobianMatrix[6][6] = 1;
//==This code has been autogenerated using Compgen==

          //Solving equation using LU-faktorisation
          mpSolver->solve(jacobianMatrix, systemEquations, stateVark, iter);
          qmp2=stateVark[0];
          wmr1=stateVark[1];
          dEp1=stateVark[2];
          dEp2=stateVark[3];
          pp1=stateVark[4];
          pp2=stateVark[5];
          tormr1=stateVark[6];
          //Expressions
          qmp1 = -qmp2;
          q2 = (qmp2*R*(1. + Tp2))/pp2;
        }

        //Calculate the delayed parts
        delayParts2[1] = (-1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1 - \
2.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp1 + \
2.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp1 + \
0.002*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1 - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2) + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Power(Tp1,2) + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2) - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp2 + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp2 + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp2 - \
2.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Tp1*Tp2 + \
2.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Tp1*Tp2 + \
0.002*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Tp2 - \
1.*Power(A2,2)*mTimestep*pp1*Power(pp2,2)*qmp2*R*Power(Tp1,2)*Tp2 + \
1.*Power(A2,2)*mTimestep*Power(pp2,3)*qmp2*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*wmr1 - \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*wmr1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*wmr1 - \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*wmr1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*wmr1 - \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1 + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Abs(wmr1) + \
2.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Tp1*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*mTimestep*Power(pp2,2)*R*tormr1*Power(Tp1,2)*Tp2*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*wmr1*Abs(wmr1) - \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*wmr1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*wmr1*Abs(wmr1) - \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*wmr1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*wmr1*Abs(wmr1) - \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*wmr1*Abs(wmr1) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*onNegative(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*onNegative(qmp2) + \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*onNegative(qmp2) - \
4.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*onNegative(qmp2) + \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*Tp1*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Power(Tp1,2)*onNegativ\
e(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Power(Tp1,2)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp2,5)*Power(Tp1,2)*onNegative(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp1*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp2*onPositive(qmp2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp2*onPositive(qmp2) + \
1.*Power(A2,2)*Kcp*mTimestep*Power(pp1,3)*Power(pp2,2)*Tp1*Tp2*onPositive(qmp\
2) - \
2.*Power(A2,2)*Kcp*mTimestep*Power(pp1,2)*Power(pp2,3)*Tp1*Tp2*onPositive(qmp\
2) + 1.*Power(A2,2)*Kcp*mTimestep*pp1*Power(pp2,4)*Tp1*Tp2*onPositive(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp2*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Tp2*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,2)*sign(qmp2) + \
1.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,2)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Power(Tp2,3)*sign(qmp2) + \
0.5*kl*mTimestep*pp1*Power(qmp2,3)*Power(R,2)*Tp1*Power(Tp2,3)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*onNegative(qmp2)*sign(q\
mp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*onNegative(qmp2)*sign(q\
mp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*onNegative(qmp2)*si\
gn(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*onNegative(qmp2)*si\
gn(qmp2) - \
1.*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onNegative(qmp2)*sig\
n(qmp2) + \
1.*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp2*onNegative(qmp2)*sig\
n(qmp2) - \
1.*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*Tp2*onNegative(qmp2)\
*sign(qmp2) + \
1.*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*Tp2*onNegative(qmp2)\
*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onNegative\
(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Power(Tp2,2)*onNegative\
(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp1*Power(Tp2,2)*onNega\
tive(qmp2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*pp1*Power(pp2,2)*Power(qmp2,2)*R*Tp1*Power(Tp2,2)*onNega\
tive(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*onPositive(qmp2)*sign(qmp2) \
+ \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*onPositive(qmp2)*sign(q\
mp2) - \
1.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*sign(q\
mp2) + \
1.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Tp2*onPositive(qmp2)*si\
gn(qmp2) - \
1.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,2)*onPositive(qmp\
2)*sign(qmp2) + \
1.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,2)*onPositive\
(qmp2)*sign(qmp2) - \
0.5*Kcp*kl*mTimestep*Power(pp1,3)*Power(qmp2,2)*R*Power(Tp2,3)*onPositive(qmp\
2)*sign(qmp2) + \
0.5*Kcp*kl*mTimestep*Power(pp1,2)*pp2*Power(qmp2,2)*R*Power(Tp2,3)*onPositive\
(qmp2)*sign(qmp2))/(0.002*Power(A2,2)*Jm*Power(pp2,2)*R + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R + \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1 + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2) + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2) + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2 + \
0.004*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2 + \
0.002*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
0.001*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2 + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Abs(wmr1) + \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp2*Abs(wmr1) + \
4.*Power(A2,2)*Jm*Power(pp2,2)*R*Tp1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Tp1*Tp2*Abs(wmr1) + \
2.*Power(A2,2)*Jm*Power(pp2,2)*R*Power(Tp1,2)*Tp2*Abs(wmr1) + \
1.*Power(A2,2)*Bm*mTimestep*Power(pp2,2)*R*Power(Tp1,2)*Tp2*Abs(wmr1));

        delayedPart[1][1] = delayParts1[1];
        delayedPart[2][1] = delayParts2[1];
        delayedPart[3][1] = delayParts3[1];
        delayedPart[4][1] = delayParts4[1];
        delayedPart[5][1] = delayParts5[1];
        delayedPart[6][1] = delayParts6[1];
        delayedPart[7][1] = delayParts7[1];

        //Write new values to nodes
        //Port Pp1
        (*mpND_pp1)=pp1;
        (*mpND_qmp1)=qmp1;
        (*mpND_dEp1)=dEp1;
        //Port Pp2
        (*mpND_pp2)=pp2;
        (*mpND_qmp2)=qmp2;
        (*mpND_dEp2)=dEp2;
        //Port Pmr1
        (*mpND_tormr1)=tormr1;
        (*mpND_thetamr1)=thetamr1;
        (*mpND_wmr1)=wmr1;
        (*mpND_eqInertiamr1)=eqInertiamr1;
        //outputVariables
        (*mpq2)=q2;

        //Update the delayed variabels
        mDelayedPart21.update(delayParts2[1]);

     }
    void deconfigure()
    {
        delete mpSolver;
    }
};
#endif // PNEUMATICTURBOMACHINEJ_HPP_INCLUDED
